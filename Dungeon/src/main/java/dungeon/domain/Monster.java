/*
 * @author olli m
 */
package dungeon.domain;

import dungeon.backend.Game;
import dungeon.backend.PathFinder;

public class Monster extends Actor {

    private static final int MAX_HEALTH = 10;
    private static final int DEFAULT_INTERVAL = 100;
    private static final double VISIBILITY_RANGE = 5;
    private static final double ALERT_RANGE = 10;

    private ActorState state;
    private Direction[][] paths;
    private Node lastKnownPlayerPosition;
    // should probably make this an abstract class

    public Monster(int x, int y) {
        super.setPosition(new Node(x, y));
        super.setInterval(DEFAULT_INTERVAL);
        super.setNextTurn(0);
        super.setHealth(MAX_HEALTH);
        super.setMaxHealth(MAX_HEALTH);
        boolean[] hostileSymbols = new boolean[Character.MAX_VALUE];
        hostileSymbols['@'] = true;
        super.setHostileSymbols(hostileSymbols);
        this.state = ActorState.STAY;
    }

    @Override
    public char getSymbol() {
        return 'D';
    }

    public void setPaths(Direction[][] paths) {
        this.paths = paths;
    }

    public void setState(ActorState state) {
        this.state = state;
    }

    public void reactOnSight(Game game) {
        if (this.distanceTo(game.getPlayer()) < VISIBILITY_RANGE) {
            alert(game);
        }
    }

    public void alert(Game game) {
        char[][] map = game.getMap();
        Player player = game.getPlayer();
        lastKnownPlayerPosition = player.getPosition();
        PathFinder pathFinder = game.getPathFinder();
//        if (pathFinder.getOldPlayerPosition() == null || !pathFinder.getOldPlayerPosition().equals(player.getPosition())) {
        pathFinder.computePaths(map, player.getPosition().getX(), player.getPosition().getY());
//        }
        paths = pathFinder.getPaths();
        state = ActorState.ATTACK;
//        alertNearby(game, lastKnownPlayerPosition);
    }

    private void alertNearby(Game game, Node position) {
        for (Actor actor : game.getActors()) {
            if (actor.getClass() == this.getClass()) {
                Monster monster = (Monster) actor;
                if (this.distanceTo(monster) < ALERT_RANGE) {
                    monster.state = ActorState.ATTACK;
                    monster.lastKnownPlayerPosition = position;
                    monster.paths = paths;
                }
            }
        }
    }

    @Override
    public void act(Game game, char[][] map) {
        // @param map: map generated by populateMap(), represents what the actor sees
        if (getHealth() < MAX_HEALTH * 0.33) {
            state = ActorState.FLEE;
        }
        if (state == ActorState.ATTACK) {
            advance(game, map);
        } else if (state == ActorState.FLEE) {
            flee(game, map);
        } else if (state == ActorState.STAY) {
            idle();
        }
    }

    private boolean advance(Game game, char[][] map) {
        Direction direction = paths[getPosition().getY()][getPosition().getX()];
        if (direction == null) {
            return false;
        }
        Node next = getPosition().translateToNew(direction);
        move(direction, game, map);
        return true;
    }

    private void flee(Game game, char[][] map) {
        Direction away = null;
        double furthest = 0;
        for (Direction direction : Direction.values()) {
            Node next = getPosition().translateToNew(direction);
            double distance = next.differenceTo(game.getPlayer().getPosition());
            if (distance > furthest) {
                away = direction;
                furthest = distance;
            }
        }
        if (away != null) {
            move(away, game, map);
        }
    }
}
