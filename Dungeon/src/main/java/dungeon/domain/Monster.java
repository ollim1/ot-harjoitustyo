/*
 * @author olli m
 */
package dungeon.domain;

import dungeon.backend.Game;
import dungeon.backend.PathFinder;

/**
 * This class is the primary enemy of the game. Will make this an abstract class
 * if I decide to add multiple monster classes. AI should probably be refactored
 * into another class.
 */
public class Monster extends Actor {

    private static final int MAX_HEALTH = 20;
    private double visionRadius;
    private double fleeThreshold;
    private static final double ALERT_RANGE = 10;

    private ActorState state;
    private boolean alerted;

    public Monster(int x, int y) {
        super.setPosition(new Node(x, y));
        super.setNextTurn(0);
        super.setHealth(MAX_HEALTH);
        super.setMaxHealth(MAX_HEALTH);
        super.setIntervalModifier(1.0);
        boolean[] hostileSymbols = new boolean[Character.MAX_VALUE];
        hostileSymbols['@'] = true;
        super.setHostileSymbols(hostileSymbols);
        this.visionRadius = 5;
        this.fleeThreshold = 0.25;
        this.state = ActorState.STAY;
        this.alerted = false;
    }

    @Override
    public char getSymbol() {
        return 'D';
    }

    public void setState(ActorState state) {
        this.state = state;
    }

    public void setVisionRadius(double visionRadius) {
        this.visionRadius = visionRadius;
    }

    public double getFleeThreshold() {
        return fleeThreshold;
    }

    public void setFleeThreshold(double fleeThreshold) {
        this.fleeThreshold = fleeThreshold;
    }

    public void reactOnSight(Game game) {
        if (this.distanceTo(game.getPlayer()) < visionRadius) {
            alert(game);
        }
    }

    /**
     * Setting up an alert that spreads to nearby monsters.
     *
     * @param game
     */
    public void alert(Game game) {
        char[][] map = game.getMap();
        Player player = game.getPlayer();
        PathFinder pathFinder = game.getPathFinder();
        if (!pathFinder.getOldCenter().equals(player.getPosition())) {
            pathFinder.computePaths(map, player.getPosition().getX(), player.getPosition().getY());
        }
        DijkstraMap attackMap = pathFinder.dijkstraMap();
        if (state == ActorState.FLEE) {
            setDijkstraMap(attackMap.copy().invert());
        }
        setDijkstraMap(attackMap);
        state = ActorState.ATTACK;
        this.alerted = true;
        alertNearby(game, attackMap);
    }

    private void alertNearby(Game game, DijkstraMap attackMap) {
        for (Actor actor : game.getActors()) {
            if (actor.getClass() == this.getClass()) {
                Monster monster = (Monster) actor;
                if (this.distanceTo(monster) < ALERT_RANGE && !monster.alerted) {
                    monster.alerted = true;
                    monster.state = ActorState.ATTACK;
                    monster.setDijkstraMap(attackMap);
                }
            }
        }
    }

    /**
     * Monster AI: Wait in place until player sighted; flee if HP low; wait
     * until
     *
     * @param game
     * @param map map generated by populateMap(), represents what the actor sees
     */
    @Override
    public void act(Game game, char[][] map) {
        if (getDijkstraMap() == null) {
            setDijkstraMap(new DijkstraMap(map[0].length, map.length));
        }
        if (getHealth() < MAX_HEALTH * fleeThreshold && state != ActorState.FLEE) {
            alerted = false;
            state = ActorState.FLEE;
            setDijkstraMap(getDijkstraMap().copy().invert());
        } else if (state == ActorState.FLEE) {
            state = ActorState.STAY;
        }
        if (state == ActorState.STAY) {
            idle();
        } else {
            followDijkstraMap(game, map);
        }
        heal();
    }

    private boolean followDijkstraMap(Game game, char[][] map) {
        for (Direction direction : getDijkstraMap().candidates(getPosition())) {
            if (move(direction, game, map)) {
                return true;
            }
        }
        return false;
    }

}
